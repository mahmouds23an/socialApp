{"ast":null,"code":"// src/queryObserver.ts\nimport { isServer, isValidTimeout, noop, replaceData, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { canFetch } from \"./retryer.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult; // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */new Set();\n\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n\n      this.#updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== \"undefined\" && typeof this.options.enabled !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean\");\n    }\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.#updateQuery();\n    const mounted = this.hasListeners();\n\n    if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {\n      this.#executeFetch();\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.#updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval();\n\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n\n  refetch() {\n    let { ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    return this.#executeFetch({ ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(this.options, fetchOptions);\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, this.options.staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const {\n      state\n    } = query;\n    let {\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPlaceholderData = false;\n    let data;\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? \"fetching\" : \"paused\";\n\n        if (!state.dataUpdatedAt) {\n          status = \"pending\";\n        }\n      }\n\n      if (options._optimisticResults === \"isRestoring\") {\n        fetchStatus = \"idle\";\n      }\n    }\n\n    if (options.select && typeof state.data !== \"undefined\") {\n      if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = state.data;\n    }\n\n    if (typeof options.placeholderData !== \"undefined\" && typeof data === \"undefined\" && status === \"pending\") {\n      let placeholderData;\n\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== \"undefined\") {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== \"undefined\") {\n        status = \"success\";\n        data = replaceData(prevResult?.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n\n    const isFetching = fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const result = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue ?? this.#trackedProps);\n\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n\n      return Object.keys(this.#currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.#notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n\n    if (query === this.#currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate() {\n    this.updateResult();\n\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.#currentResult);\n        });\n      }\n\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n\n};\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport { QueryObserver };","map":{"version":3,"mappings":"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","names":["isServer","isValidTimeout","noop","replaceData","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","canFetch","QueryObserver","constructor","client","options","bindMethods","setOptions","Set","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","getQueryCache","notify","type","query","observer","enabled","Error","queryKey","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","cancelRefetch","promise","throwOnError","catch","isStale","time","dataUpdatedAt","timeout","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","error","errorUpdatedAt","fetchStatus","status","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","networkMode","select","selectError","placeholderData","Date","now","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","some","typedKey","changed","has","onQueryUpdate","batch","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","value","suspense","isStaleByTime","optimisticResult"],"sources":["D:\\Work\\socialApp\\client\\node_modules\\@tanstack\\query-core\\src\\queryObserver.ts"],"sourcesContent":["import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch } from './retryer'\nimport type { QueryClient } from './queryClient'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps: Set<keyof QueryObserverResult> = new Set()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.#updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.#currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let { error, errorUpdatedAt, fetchStatus, status } = state\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!state.dataUpdatedAt) {\n          status = 'pending'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}